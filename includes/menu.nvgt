void mainmenu()
{
setupmenu();
m.add_item_tts("generate scenario", "gen");
m.add_item_tts("scenario manager", "manage");
m.add_item_tts("scenario statistics", "stats");
m.add_item_tts("exit", "ex");
int mres=m.run("Main menu. Please choose an option with your arrow keys, then press enter to activate one.",true);
string main=m.get_item_name(mres);
if(mres==0)
{
speak("exiting");
m.fade_music();
exit();
}
if(main=="gen")
{
m.fade_music();
setupmenu(false);
m.add_item_tts("male", "ml");
m.add_item_tts("female", "fl");
m.add_item_tts("back", "back");
int mres=m.run("Choose the gender you'd like to use for this generation.",true);
string gend=m.get_item_name(mres);
if(mres==0)
{
mainmenu();
}
if(gend=="ml")
{
sengender="male";
string[] senarpacks=find_directories("data/scenarios/*");
if(senarpacks.length()==0)
{
alert("Error", "There are no scenario packs available to view.");
wait(500);
mainmenu();
}
else if(senarpacks.length()==1)
{
sengender="male";
senpack = senarpacks[0];
speak("loading");
wait(500);
health=10000;
maxhealth=10000;
genscen();
}
else
{
setupmenu(false);
for(uint i=0; i<senarpacks.length(); i++)
{
m.add_item_tts(senarpacks[i], senarpacks[i]);
}
int mres=m.run("Choose the scenario pack you'd like to use for this generation.", true);
if(mres==0)
{
mainmenu();
}
if (mres==0 and mres>=senarpacks.length())
{
senpack=senarpacks[mres-1];
}
if (mres>0 and mres<=senarpacks.length())
{
senpack=senarpacks[mres-1];
speak("loading");
wait(500);
health=10000;
maxhealth=10000;
genscen();
}
}
}
if(gend=="fl")
{
sengender="female";
string[] senarpacks=find_directories("data/scenarios/*");
if(senarpacks.length()==0)
{
alert("Error", "There are no scenario packs available to view.");
wait(500);
mainmenu();
}
else if(senarpacks.length()==1)
{
sengender="female";
senpack = senarpacks[0];
speak("loading");
wait(500);
health=10000;
maxhealth=10000;
genscen();
}
else
{
setupmenu(false);
for(uint i=0; i<senarpacks.length(); i++)
{
m.add_item_tts(senarpacks[i], senarpacks[i]);
}
int mres=m.run("Choose the scenario pack you'd like to use for this generation.", true);
if(mres==0)
{
mainmenu();
}
if (mres==0 and mres>=senarpacks.length())
{
senpack=senarpacks[mres-1];
}
if (mres>0 and mres<=senarpacks.length())
{
senpack=senarpacks[mres-1];
speak("loading");
wait(500);
health=10000;
maxhealth=10000;
genscen();
}
}
}
if(gend=="back")
{
mainmenu();
}
}
if(main=="manage")
{
string[] senarpacks=find_directories("data/scenarios/*");
if(senarpacks.length()==0)
{
alert("Error", "There are no scenario packs available to view.");
wait(500);
mainmenu();
}
else if(senarpacks.length()==1)
{
senpack = senarpacks[0];
scencredmenu();
}
else
{
setupmenu();
for(uint i=0; i<senarpacks.length(); i++)
{
m.add_item_tts(senarpacks[i], senarpacks[i]);
}
int mres=m.run("Choose the scenario pack you'd like to use in this menu.", true);
if(mres==0)
{
mainmenu();
}
if (mres==0 and mres>=senarpacks.length())
{
senpack=senarpacks[mres-1];
}
if (mres>0 and mres<=senarpacks.length())
{
senpack=senarpacks[mres-1];
scencredmenu();
}
}
}
if(main=="stats")
{
string[] senarpacks=find_directories("data/scenarios/*");
if(senarpacks.length()==0)
{
alert("Error", "There are no scenario packs available to view.");
wait(500);
mainmenu();
}
else if(senarpacks.length()==1)
{
senpack = senarpacks[0];
statsmenu();
}
else
{
setupmenu();
for(uint i=0; i<senarpacks.length(); i++)
{
m.add_item_tts(senarpacks[i], senarpacks[i]);
}
int mres=m.run("Choose the scenario pack you'd like to use in this menu.", true);
if(mres==0)
{
mainmenu();
}
if (mres==0 and mres>=senarpacks.length())
{
senpack=senarpacks[mres-1];
}
if (mres>0 and mres<=senarpacks.length())
{
senpack=senarpacks[mres-1];
statsmenu();
}
}
}
if(main=="ex")
{
speak("exiting");
m.fade_music();
exit();
}
}
void scencredmenu()
{
setupmenu();
m.add_item_tts("add scenarios", "ascen");
m.add_item_tts("edit scenarios", "escen");
m.add_item_tts("remove scenarios", "rscen");
m.add_item_tts("view scenarios", "vscen");
m.add_item_tts("back", "back");
string[] senarpacks=find_directories("data/scenarios/*");
int mres;
if(senarpacks.length()==1) mres=m.run("Scenario manager menu.",true);
else if(senarpacks.length()>1) mres=m.run(senpack+" loaded: Scenario manager menu.",true);
string scm=m.get_item_name(mres);
if(mres==0)
{
mainmenu();
}
if(scm=="ascen")
{
adscenmenu();
}
if(scm=="escen")
{
edscenmenu();
}
if(scm=="rscen")
{
remscenmenu();
}
if(scm=="vscen")
{
vewscenmenu();
}
if(scm=="back")
{
mainmenu();
}
}
void adscenmenu()
{
setupmenu();
m.add_item_tts("actions", "act");
m.add_item_tts("attacks", "ak");
m.add_item_tts("body parts", "bpart");
m.add_item_tts("character names", "cname");
m.add_item_tts("character types", "ctype");
m.add_item_tts("death messages", "dmessage");
m.add_item_tts("moods", "mod");
m.add_item_tts("pain messages", "pmessage");
m.add_item_tts("reasons", "res");
m.add_item_tts("template categories", "temps");
m.add_item_tts("back", "back");
int mres=m.run("Add scenarios menu. What would you like to add?",true);
string ascm=m.get_item_name(mres);
if(mres==0)
{
scencredmenu();
}
if(ascm=="act")
{
m.fade_music();
actions.open("data/scenarios/"+senpack+"/actions.list", "a");
vd.set_disallowed_chars(disachars, false, disadesc);
string newact=vd.input_box("", "Enter the action you'd like to add.");
if(newact.empty())
{
alert("Error", "You must enter a valid action.");
wait(500);
adscenmenu();
}
else
{
actions.write("\r\n"+newact);
actions.close();
dlg_return("Success! Your action has been added to the actions list.");
adscenmenu();
}
}
if(ascm=="ak")
{
m.fade_music();
attacks.open("data/scenarios/"+senpack+"/attacks.list", "a");
vd.set_disallowed_chars(disachars, false, disadesc);
string newak=vd.input_box("", "Enter the attack you'd like to add.");
if(newak.empty())
{
alert("Error", "You must enter a valid attack.");
wait(500);
adscenmenu();
}
else
{
attacks.write("\r\n"+newak);
attacks.close();
dlg_return("Success! Your attack has been added to the attacks list.");
adscenmenu();
}
}
if(ascm=="bpart")
{
m.fade_music();
bodyparts.open("data/scenarios/"+senpack+"/bodyparts.list", "a");
vd.set_disallowed_chars(disachars, false, disadesc);
string newbpart=vd.input_box("", "Enter the body part you'd like to add.");
if(newbpart.empty())
{
alert("Error", "You must enter a valid body part.");
wait(500);
adscenmenu();
}
else
{
bodyparts.write("\r\n"+newbpart);
bodyparts.close();
dlg_return("Success! Your body part has been added to the body parts list.");
adscenmenu();
}
}
if(ascm=="cname")
{
m.fade_music();
charnames.open("data/scenarios/"+senpack+"/charnames.list", "a");
vd.set_disallowed_chars(disachars, false, disadesc);
string newcname=vd.input_box("", "Enter the character name you'd like to add.");
if(newcname.empty())
{
alert("Error", "You must enter a valid character name.");
wait(500);
adscenmenu();
}
else
{
charnames.write("\r\n"+newcname);
charnames.close();
dlg_return("Success! Your character name has been added to the character names list.");
adscenmenu();
}
}
if(ascm=="ctype")
{
m.fade_music();
chartypes.open("data/scenarios/"+senpack+"/chartypes.list", "a");
vd.set_disallowed_chars(disachars, false, disadesc);
string newctype=vd.input_box("", "Enter the character type you'd like to add.");
if(newctype.empty())
{
alert("Error", "You must enter a valid character type.");
wait(500);
adscenmenu();
}
else
{
chartypes.write("\r\n"+newctype);
chartypes.close();
dlg_return("Success! Your character type has been added to the character types list.");
adscenmenu();
}
}
if(ascm=="dmessage")
{
m.fade_music();
deaths.open("data/scenarios/"+senpack+"/deaths.list", "a");
vd.set_disallowed_chars(disachars, false, disadesc);
string newdmessage=vd.input_box("", "Enter the death message you'd like to add.");
if(newdmessage.empty())
{
alert("Error", "You must enter a valid death message.");
wait(500);
adscenmenu();
}
else
{
deaths.write("\r\n"+newdmessage);
deaths.close();
dlg_return("Success! Your death message has been added to the death messages list.");
adscenmenu();
}
}
if(ascm=="mod")
{
m.fade_music();
moods.open("data/scenarios/"+senpack+"/moods.list", "a");
vd.set_disallowed_chars(disachars, false, disadesc);
string newmod=vd.input_box("", "Enter the mood you'd like to add.");
if(newmod.empty())
{
alert("Error", "You must enter a valid mood.");
wait(500);
adscenmenu();
}
else
{
moods.write("\r\n"+newmod);
moods.close();
dlg_return("Success! Your mood has been added to the moods list.");
adscenmenu();
}
}
if(ascm=="pmessage")
{
m.fade_music();
pains.open("data/scenarios/"+senpack+"/pains.list", "a");
vd.set_disallowed_chars(disachars, false, disadesc);
string newpmessage=vd.input_box("", "Enter the pain message you'd like to add.");
if(newpmessage.empty())
{
alert("Error", "You must enter a valid pain message.");
wait(500);
adscenmenu();
}
else
{
pains.write("\r\n"+newpmessage);
pains.close();
dlg_return("Success! Your pain message has been added to the pain messages list.");
adscenmenu();
}
}
if(ascm=="res")
{
m.fade_music();
reasons.open("data/scenarios/"+senpack+"/reasons.list", "a");
vd.set_disallowed_chars(disachars, false, disadesc);
string newres=vd.input_box("", "Enter the reason you'd like to add.");
if(newres.empty())
{
alert("Error", "You must enter a valid reason.");
wait(500);
adscenmenu();
}
else
{
reasons.write("\r\n"+newres);
reasons.close();
dlg_return("Success! Your reason has been added to the reasons list.");
adscenmenu();
}
}
if(ascm == "temps")
{
    m.fade_music();
    vd.set_disallowed_chars(disachars, false, disadesc);
    string newCat = vd.input_box("", "Enter the name of this template category.");
    if (newCat.empty())
    {
        alert("Error", "You must enter a valid template category.");
        wait(500);
        adscenmenu();
    }
    string[] tokens;
    string[] texts;
    vd.set_disallowed_chars(disachars, false, disadesc);
    tokens.insert_last(vd.input_box("", "Enter the first token of this template category. Example, {pain}."));
    if (tokens[0].empty()) {
        alert("Error", "Token 1 is empty. Please enter a valid token for this template category.");
        wait(500);
        adscenmenu();
    }
    texts.insert_last(vd.input_box("", "Enter the first text of this template category. Example, Your."));
    if (texts[0].empty()) {
        alert("Error", "Text 1 is empty. Please enter a valid text segment for this template category.");
        wait(500);
        adscenmenu();
    }
    tokens.insert_last(vd.input_box("", "Enter the second token of this template category. Example, {chartype}."));
    if (tokens[1].empty()) {
        alert("Error", "Token 2 is empty. Please enter a valid token for this template category.");
        wait(500);
        adscenmenu();
    }
    tokens.insert_last(vd.input_box("", "Enter the third token of this template category. Example, {charname}."));
    if (tokens[2].empty()) {
        alert("Error", "Token 3 is empty. Please enter a valid token for this template category.");
        wait(500);
        adscenmenu();
    }
    tokens.insert_last(vd.input_box("", "Enter the fourth token of this template category. Example, {action}."));
    if (tokens[3].empty()) {
        alert("Error", "Token 4 is empty. Please enter a valid token for this template category.");
        wait(500);
        adscenmenu();
    }
    texts.insert_last(vd.input_box("", "Enter the second text of this template category. Example, your."));
    if (texts[1].empty()) {
        alert("Error", "Text 2 is empty. Please enter a valid text segment for this template category.");
        wait(500);
        adscenmenu();
    }
    tokens.insert_last(vd.input_box("", "Enter the fifth token of this template category. Example, {bodypart}."));
    if (tokens[4].empty()) {
        alert("Error", "Token 5 is empty. Please enter a valid token for this template category.");
        wait(500);
        adscenmenu();
    }
    texts.insert_last(vd.input_box("", "Enter the third text of this template category. Example, with their."));
    if (texts[2].empty()) {
        alert("Error", "Text 3 is empty. Please enter a valid text segment for this template category.");
        wait(500);
        adscenmenu();
    }
    tokens.insert_last(vd.input_box("", "Enter the sixth token of this template category. Example, {attack}."));
    if (tokens[5].empty()) {
        alert("Error", "Token 6 is empty. Please enter a valid token for this template category.");
        wait(500);
        adscenmenu();
    }
    texts.insert_last(vd.input_box("", "Enter the fourth text of this template category. Example, because they were."));
    if (texts[3].empty()) {
        alert("Error", "Text 4 is empty. Please enter a valid text segment for this template category.");
        wait(500);
        adscenmenu();
    }
    tokens.insert_last(vd.input_box("", "Enter the seventh token of this template category. Example, {mood}."));
    if (tokens[6].empty()) {
        alert("Error", "Token 7 is empty. Please enter a valid token for this template category.");
        wait(500);
        adscenmenu();
    }
    texts.insert_last(vd.input_box("", "Enter the fifth text of this template category. Example, that you."));
    if (texts[4].empty()) {
        alert("Error", "Text 5 is empty. Please enter a valid text segment for this template category.");
        wait(500);
        adscenmenu();
    }
    tokens.insert_last(vd.input_box("", "Enter the eighth token of this template category. Example, {reason}."));
    if (tokens[7].empty()) {
        alert("Error", "Token 8 is empty. Please enter a valid token for this template category.");
        wait(500);
        adscenmenu();
    }
    texts.insert_last(vd.input_box("", "Enter the sixth text of this template category. Example, causing you to lose."));
    if (texts[5].empty()) {
        alert("Error", "Text 6 is empty. Please enter a valid text segment for this template category.");
        wait(500);
        adscenmenu();
    }
    tokens.insert_last(vd.input_box("", "Enter the ninth token of this template category. Example, {dmg}."));
    if (tokens[8].empty()) {
        alert("Error", "Token 9 is empty. Please enter a valid token for this template category.");
        wait(500);
        adscenmenu();
    }
    texts.insert_last(vd.input_box("", "Enter the seventh text of this template category. Example, % of your health!"));
    if (texts[6].empty()) {
        alert("Error", "Text 7 is empty. Please enter a valid text segment for this template category.");
        wait(500);
        adscenmenu();
    }
string newTemplate = "";
newTemplate += "{" + tokens[0] + "} ";
newTemplate += texts[0] + " ";
newTemplate += "{" + tokens[1] + "}, {" + tokens[2] + "}, {" + tokens[3] + "} ";
newTemplate += texts[1] + " ";
newTemplate += "{" + tokens[4] + "} ";
newTemplate += texts[2] + " ";
newTemplate += "{" + tokens[5] + "} ";
newTemplate += texts[3] + " ";
newTemplate += "{" + tokens[6] + "} ";
newTemplate += texts[4] + " ";
newTemplate += "{" + tokens[7] + "} ";
newTemplate += texts[5] + " ";
newTemplate += "{" + tokens[8] + "} ";
newTemplate += texts[6];
setupmenu(false);
m.add_item_tts("Yes");
m.add_item_tts("No");
int mres = m.run("Would you like to edit your template category before saving it?", true);
if(mres == 0)
{
alert("Error", "Template creation aborted.");
wait(500);
adscenmenu();
}
if (mres == 1)
{
vd.set_disallowed_chars(disachars, false, disadesc);
string edited = vd.input_box("", "Enter the new text of this template category.", newTemplate);
if (edited.empty())
{
alert("Error", "You must enter a valid template text.");
wait(500);
adscenmenu();
}
newTemplate = edited;
}
if (mres == 2)
{
templates.open("data/scenarios/" + senpack + "/templates.list", "a");
templates.write("\r\n[" + newCat + "]\r\n" + newTemplate + "\r\n");
templates.close();
dlg_return("Success! Your template category has been added to the templates list.");
adscenmenu();
}
}
if(ascm=="back")
{
scencredmenu();
}
}
void edscenmenu()
{
setupmenu();
m.add_item_tts("actions", "act2");
m.add_item_tts("attacks", "ak2");
m.add_item_tts("body parts", "bpart2");
m.add_item_tts("character names", "cname2");
m.add_item_tts("character types", "ctype2");
m.add_item_tts("death messages", "dmessage2");
m.add_item_tts("moods", "mod2");
m.add_item_tts("pain messages", "pmessage2");
m.add_item_tts("reasons", "res2");
m.add_item_tts("template categories", "temps2");
m.add_item_tts("back", "back");
int mres=m.run("Edit scenarios menu. What would you like to edit?",true);
string escm=m.get_item_name(mres);
if(mres==0)
{
scencredmenu();
}
if (escm == "act2")
{
    m.fade_music();
    actions.open("data/scenarios/" + senpack + "/actions.list", "r");
    actionsplit = actions.read();
    actions.close();
    string[] rawActions = string_split(actionsplit, "\r\n", true);
    string[] filteredActions;
    uint[] originalIndexes;
    filter_empty_lines(rawActions, filteredActions, originalIndexes);
    if (filteredActions.length() == 0)
    {
        alert("Error", "There are no actions available to edit.");
        wait(500);
        edscenmenu();
    }
    setupmenu(false);
    for (uint i = 0; i < filteredActions.length(); i++)
    {
        m.add_item_tts(filteredActions[i], filteredActions[i], "", true);
    }
    int mres = m.run("Select an action to edit", true);
    if (mres == 0)
    {
        edscenmenu();
    }
    if (mres > 0 and mres <= filteredActions.length())
    {
        int realIndex = originalIndexes[mres - 1];
        vd.set_disallowed_chars(disachars, false, disadesc);
        string editedAction = vd.input_box("", "Enter the new name for this action.", rawActions[realIndex]);
if(editedAction.empty())
{
alert("Error", "You must enter a valid action.");
wait(500);
edscenmenu();
}
else
{
        rawActions[realIndex] = editedAction;
        string final = "";
        for (uint i = 0; i < rawActions.length(); i++)
        {
            if (i > 0) final += "\r\n";
            final += rawActions[i];
        }
        actions.open("data/scenarios/" + senpack + "/actions.list", "w");
        actions.write(final);
        actions.close();
dlg_return("Success! Your action has been edited from the actions list.");
        edscenmenu();
    }
}
}
if (escm == "ak2")
{
    m.fade_music();
    attacks.open("data/scenarios/" + senpack + "/attacks.list", "r");
    attacksplit = attacks.read();
    attacks.close();
    string[] rawAttacks = string_split(attacksplit, "\r\n", true);
    string[] filteredAttacks;
    uint[] originalIndexes;
    filter_empty_lines(rawAttacks, filteredAttacks, originalIndexes);
    if (filteredAttacks.length() == 0)
    {
        alert("Error", "There are no attacks available to edit.");
        wait(500);
        edscenmenu();
    }
    setupmenu(false);
    for (uint i = 0; i < filteredAttacks.length(); i++)
    {
        m.add_item_tts(filteredAttacks[i], filteredAttacks[i], "", true);
    }
    int mres = m.run("Select an attack to edit", true);
    if (mres == 0)
    {
        edscenmenu();
    }
    if (mres > 0 and mres <= filteredAttacks.length())
    {
        int realIndex = originalIndexes[mres - 1];
        vd.set_disallowed_chars(disachars, false, disadesc);
        string editedAttack = vd.input_box("", "Enter the new name for this attack.", rawAttacks[realIndex]);
if(editedAttack.empty())
{
alert("Error", "You must enter a valid attack.");
wait(500);
edscenmenu();
}
else
{
        rawAttacks[realIndex] = editedAttack;
        string final = "";
        for (uint i = 0; i < rawAttacks.length(); i++)
        {
            if (i > 0) final += "\r\n";
            final += rawAttacks[i];
        }
        attacks.open("data/scenarios/" + senpack + "/attacks.list", "w");
        attacks.write(final);
        attacks.close();
dlg_return("Success! Your attack has been edited from the attacks list.");
        edscenmenu();
    }
}
}
if (escm == "bpart2")
{
    m.fade_music();
    bodyparts.open("data/scenarios/" + senpack + "/bodyparts.list", "r");
    bodypartsplit = bodyparts.read();
    bodyparts.close();
    string[] rawBodyparts = string_split(bodypartsplit, "\r\n", true);
    string[] filteredBodyparts;
    uint[] originalIndexes;
    filter_empty_lines(rawBodyparts, filteredBodyparts, originalIndexes);
    if (filteredBodyparts.length() == 0)
    {
        alert("Error", "There are no body parts available to edit.");
        wait(500);
        edscenmenu();
    }
    setupmenu(false);
    for (uint i = 0; i < filteredBodyparts.length(); i++)
    {
        m.add_item_tts(filteredBodyparts[i], filteredBodyparts[i], "", true);
    }
    int mres = m.run("Select a body part to edit", true);
    if (mres == 0)
    {
        edscenmenu();
    }
    if (mres > 0 and mres <= filteredBodyparts.length())
    {
        int realIndex = originalIndexes[mres - 1];
        vd.set_disallowed_chars(disachars, false, disadesc);
        string editedBodypart = vd.input_box("", "Enter the new name for this body part.", rawBodyparts[realIndex]);
if(editedBodypart.empty())
{
alert("Error", "You must enter a valid body part.");
wait(500);
edscenmenu();
}
else
{
        rawBodyparts[realIndex] = editedBodypart;
        string final = "";
        for (uint i = 0; i < rawBodyparts.length(); i++)
        {
            if (i > 0) final += "\r\n";
            final += rawBodyparts[i];
        }
        bodyparts.open("data/scenarios/" + senpack + "/bodyparts.list", "w");
        bodyparts.write(final);
        bodyparts.close();
dlg_return("Success! Your body part has been edited from the bodyparts list.");
        edscenmenu();
    }
}
}
if (escm == "cname2")
{
    m.fade_music();
    charnames.open("data/scenarios/" + senpack + "/charnames.list", "r");
    charnamesplit = charnames.read();
    charnames.close();
    string[] rawCharnames = string_split(charnamesplit, "\r\n", true);
    string[] filteredCharnames;
    uint[] originalIndexes;
    filter_empty_lines(rawCharnames, filteredCharnames, originalIndexes);
    if (filteredCharnames.length() == 0)
    {
        alert("Error", "There are no character names available to edit.");
        wait(500);
        edscenmenu();
    }
    setupmenu(false);
    for (uint i = 0; i < filteredCharnames.length(); i++)
    {
        m.add_item_tts(filteredCharnames[i], filteredCharnames[i], "", true);
    }
    int mres = m.run("Select a character name to edit", true);
    if (mres == 0)
    {
        edscenmenu();
    }
    if (mres > 0 and mres <= filteredCharnames.length())
    {
        int realIndex = originalIndexes[mres - 1];
        vd.set_disallowed_chars(disachars, false, disadesc);
        string editedCharname = vd.input_box("", "Enter the new name for this character name.", rawCharnames[realIndex]);
if(editedCharname.empty())
{
alert("Error", "You must enter a valid character name.");
wait(500);
edscenmenu();
}
else
{
        rawCharnames[realIndex] = editedCharname;
        string final = "";
        for (uint i = 0; i < rawCharnames.length(); i++)
        {
            if (i > 0) final += "\r\n";
            final += rawCharnames[i];
        }
        charnames.open("data/scenarios/" + senpack + "/charnames.list", "w");
        charnames.write(final);
        charnames.close();
dlg_return("Success! Your character name has been edited from the character names list.");
        edscenmenu();
    }
}
}
if (escm == "ctype2")
{
    m.fade_music();
    chartypes.open("data/scenarios/" + senpack + "/chartypes.list", "r");
    chartypesplit = chartypes.read();
    chartypes.close();
    string[] rawChartypes = string_split(chartypesplit, "\r\n", true);
    string[] filteredChartypes;
    uint[] originalIndexes;
    filter_empty_lines(rawChartypes, filteredChartypes, originalIndexes);
    if (filteredChartypes.length() == 0)
    {
        alert("Error", "There are no character types available to edit.");
        wait(500);
        edscenmenu();
    }
    setupmenu(false);
    for (uint i = 0; i < filteredChartypes.length(); i++)
    {
        m.add_item_tts(filteredChartypes[i], filteredChartypes[i], "", true);
    }
    int mres = m.run("Select a character type to edit", true);
    if (mres == 0)
    {
        edscenmenu();
    }
    if (mres > 0 and mres <= filteredChartypes.length())
    {
        int realIndex = originalIndexes[mres - 1];
        vd.set_disallowed_chars(disachars, false, disadesc);
        string editedChartype = vd.input_box("", "Enter the new name for this character type.", rawChartypes[realIndex]);
if(editedChartype.empty())
{
alert("Error", "You must enter a valid character type.");
wait(500);
edscenmenu();
}
else
{
        rawChartypes[realIndex] = editedChartype;
        string final = "";
        for (uint i = 0; i < rawChartypes.length(); i++)
        {
            if (i > 0) final += "\r\n";
            final += rawChartypes[i];
        }
        chartypes.open("data/scenarios/" + senpack + "/chartypes.list", "w");
        chartypes.write(final);
        chartypes.close();
dlg_return("Success! Your character type has been edited from the character types list.");
        edscenmenu();
    }
}
}
if (escm == "dmessage2")
{
    m.fade_music();
    deaths.open("data/scenarios/" + senpack + "/deaths.list", "r");
    deathsplit = deaths.read();
    deaths.close();
    string[] rawDeaths = string_split(deathsplit, "\r\n", true);
    string[] filteredDeaths;
    uint[] originalIndexes;
    filter_empty_lines(rawDeaths, filteredDeaths, originalIndexes);
    if (filteredDeaths.length() == 0)
    {
        alert("Error", "There are no death messages available to edit.");
        wait(500);
        edscenmenu();
    }
    setupmenu(false);
    for (uint i = 0; i < filteredDeaths.length(); i++)
    {
        m.add_item_tts(filteredDeaths[i], filteredDeaths[i], "", true);
    }
    int mres = m.run("Select a death message to edit", true);
    if (mres == 0)
    {
        edscenmenu();
    }
    if (mres > 0 and mres <= filteredDeaths.length())
    {
        int realIndex = originalIndexes[mres - 1];
        vd.set_disallowed_chars(disachars, false, disadesc);
        string editedDeath = vd.input_box("", "Enter the new name for this death message.", rawDeaths[realIndex]);
if(editedDeath.empty())
{
alert("Error", "You must enter a valid death message.");
wait(500);
edscenmenu();
}
else
{
        rawDeaths[realIndex] = editedDeath;
        string final = "";
        for (uint i = 0; i < rawDeaths.length(); i++)
        {
            if (i > 0) final += "\r\n";
            final += rawDeaths[i];
        }
        deaths.open("data/scenarios/" + senpack + "/deaths.list", "w");
        deaths.write(final);
        deaths.close();
dlg_return("Success! Your death message has been edited from the death messages list.");
        edscenmenu();
    }
}
}
if (escm == "mod2")
{
    m.fade_music();
    moods.open("data/scenarios/" + senpack + "/moods.list", "r");
    moodsplit = moods.read();
    moods.close();
    string[] rawMoods = string_split(moodsplit, "\r\n", true);
    string[] filteredMoods;
    uint[] originalIndexes;
    filter_empty_lines(rawMoods, filteredMoods, originalIndexes);
    if (filteredMoods.length() == 0)
    {
        alert("Error", "There are no moods available to edit.");
        wait(500);
        edscenmenu();
    }
    setupmenu(false);
    for (uint i = 0; i < filteredMoods.length(); i++)
    {
        m.add_item_tts(filteredMoods[i], filteredMoods[i], "", true);
    }
    int mres = m.run("Select a mood to edit", true);
    if (mres == 0)
    {
        edscenmenu();
    }
    if (mres > 0 and mres <= filteredMoods.length())
    {
        int realIndex = originalIndexes[mres - 1];
        vd.set_disallowed_chars(disachars, false, disadesc);
        string editedMood = vd.input_box("", "Enter the new name for this mood.", rawMoods[realIndex]);
if(editedMood.empty())
{
alert("Error", "You must enter a valid mood.");
wait(500);
edscenmenu();
}
else
{
        rawMoods[realIndex] = editedMood;
        string final = "";
        for (uint i = 0; i < rawMoods.length(); i++)
        {
            if (i > 0) final += "\r\n";
            final += rawMoods[i];
        }
        moods.open("data/scenarios/" + senpack + "/moods.list", "w");
        moods.write(final);
        moods.close();
dlg_return("Success! Your mood has been edited from the moods list.");
        edscenmenu();
    }
}
}
if (escm == "pmessage2")
{
    m.fade_music();
    pains.open("data/scenarios/" + senpack + "/pains.list", "r");
    painsplit = pains.read();
    pains.close();
    string[] rawPains = string_split(painsplit, "\r\n", true);
    string[] filteredPains;
    uint[] originalIndexes;
    filter_empty_lines(rawPains, filteredPains, originalIndexes);
    if (filteredPains.length() == 0)
    {
        alert("Error", "There are no pain messages available to edit.");
        wait(500);
        edscenmenu();
    }
    setupmenu(false);
    for (uint i = 0; i < filteredPains.length(); i++)
    {
        m.add_item_tts(filteredPains[i], filteredPains[i], "", true);
    }
    int mres = m.run("Select a pain message to edit", true);
    if (mres == 0)
    {
        edscenmenu();
    }
    if (mres > 0 and mres <= filteredPains.length())
    {
        int realIndex = originalIndexes[mres - 1];
        vd.set_disallowed_chars(disachars, false, disadesc);
        string editedPain = vd.input_box("", "Enter the new name for this pain message.", rawPains[realIndex]);
if(editedPain.empty())
{
alert("Error", "You must enter a valid pain message.");
wait(500);
edscenmenu();
}
else
{
        rawPains[realIndex] = editedPain;
        string final = "";
        for (uint i = 0; i < rawPains.length(); i++)
        {
            if (i > 0) final += "\r\n";
            final += rawPains[i];
        }
        pains.open("data/scenarios/" + senpack + "/pains.list", "w");
        pains.write(final);
        pains.close();
dlg_return("Success! Your pain message has been edited from the pain messages list.");
        edscenmenu();
    }
}
}
if (escm == "res2")
{
    m.fade_music();
    reasons.open("data/scenarios/" + senpack + "/reasons.list", "r");
    reasonsplit = reasons.read();
    reasons.close();
    string[] rawReasons = string_split(reasonsplit, "\r\n", true);
    string[] filteredReasons;
    uint[] originalIndexes;
    filter_empty_lines(rawReasons, filteredReasons, originalIndexes);
    if (filteredReasons.length() == 0)
    {
        alert("Error", "There are no reasons available to edit.");
        wait(500);
        edscenmenu();
    }
    setupmenu(false);
    for (uint i = 0; i < filteredReasons.length(); i++)
    {
        m.add_item_tts(filteredReasons[i], filteredReasons[i], "", true);
    }
    int mres = m.run("Select a reason to edit", true);
    if (mres == 0)
    {
        edscenmenu();
    }
    if (mres > 0 and mres <= filteredReasons.length())
    {
        int realIndex = originalIndexes[mres - 1];
        vd.set_disallowed_chars(disachars, false, disadesc);
        string editedReason = vd.input_box("", "Enter the new name for this reason.", rawReasons[realIndex]);
if(editedReason.empty())
{
alert("Error", "You must enter a valid reason.");
wait(500);
edscenmenu();
}
else
{
        rawReasons[realIndex] = editedReason;
        string final = "";
        for (uint i = 0; i < rawReasons.length(); i++)
        {
            if (i > 0) final += "\r\n";
            final += rawReasons[i];
        }
        reasons.open("data/scenarios/" + senpack + "/reasons.list", "w");
        reasons.write(final);
        reasons.close();
dlg_return("Success! Your reason has been edited from the reasons list.");
        edscenmenu();
    }
}
}
if(escm == "temps2")
{
    m.fade_music();
    templates.open("data/scenarios/" + senpack + "/templates.list", "r");
    string contents = templates.read();
    templates.close();
    string[] lines = string_split(contents, "\r\n", true);
    string[] categories;
    uint[] indices;
    for (uint i = 0; i < lines.length(); i++)
    {
        if (lines[i].starts_with("[") && lines[i].ends_with("]"))
        {
            categories.insert_last(lines[i].substr(1, lines[i].length() - 2));
            indices.insert_last(i);
        }
    }
    if(categories.length() == 0)
    {
        alert("Error", "There are no template categories available to edit.");
        wait(500);
        edscenmenu();
    }
    setupmenu(false);
    for (uint i = 0; i < categories.length(); i++)
    {
        m.add_item_tts(categories[i], categories[i], "", true);
    }
    int mres = m.run("Select a template category to edit", true);
    if (mres == 0)
    {
        edscenmenu();
    }
    if (mres > 0 && mres <= categories.length())
    {
        int index = indices[mres - 1];
        string oldTemplate = (index + 1 < lines.length()) ? lines[index + 1] : "";
vd.set_disallowed_chars(disachars, false, disadesc);
        string newTemplate = vd.input_box("", "Enter the new text of this template category.", oldTemplate);
        if (newTemplate.empty())
        {
            alert("Error", "You must enter a valid template text.");
            wait(500);
            edscenmenu();
        }
        else
        {
            lines[index + 1] = newTemplate;
            templates.open("data/scenarios/" + senpack + "/templates.list", "w");
            for (uint i = 0; i < lines.length(); i++)
            {
                templates.write(lines[i] + "\r\n");
            }
            templates.close();
dlg_return("Success! Your template category has been edited from the templates list.");
            edscenmenu();
        }
    }
}
if(escm=="back")
{
scencredmenu();
}
}
void remscenmenu()
{
setupmenu();
m.add_item_tts("actions", "act3");
m.add_item_tts("attacks", "ak3");
m.add_item_tts("body parts", "bpart3");
m.add_item_tts("character names", "cname3");
m.add_item_tts("character types", "ctype3");
m.add_item_tts("death messages", "dmessage3");
m.add_item_tts("moods", "mod3");
m.add_item_tts("pain messages", "pmessage3");
m.add_item_tts("reasons", "res3");
m.add_item_tts("template categories", "temps3");
m.add_item_tts("back", "back");
int mres=m.run("Remove scenarios menu. What would you like to remove?",true);
string rscm=m.get_item_name(mres);
if(mres==0)
{
scencredmenu();
}
if (rscm == "act3")
{
    m.fade_music();
    actions.open("data/scenarios/" + senpack + "/actions.list", "r");
    actionsplit = actions.read();
    actions.close();
    string[] rawActions = string_split(actionsplit, "\r\n", true);
    string[] filteredActions;
    uint[] originalIndexes;
    filter_empty_lines(rawActions, filteredActions, originalIndexes);
    if (filteredActions.length() == 0)
    {
        alert("Error", "There are no actions available to remove.");
        wait(500);
        remscenmenu();
    }
    setupmenu(false);
    for (uint i = 0; i < filteredActions.length(); i++)
    {
        m.add_item_tts(filteredActions[i], filteredActions[i], "", true);
    }
    int mres = m.run("Select an action to remove", true);
    if (mres == 0)
    {
        remscenmenu();
    }
    if (mres > 0 and mres <= filteredActions.length())
    {
        int realIndex = originalIndexes[mres - 1];
        if (realIndex >= 0 and realIndex < rawActions.length())
        {
            rawActions.remove_at(realIndex);
            string final = "";
            for (uint i = 0; i < rawActions.length(); i++)
            {
                final += rawActions[i] + "\r\n";
            }
            actions.open("data/scenarios/" + senpack + "/actions.list", "w");
            actions.write(final);
            actions.close();
            dlg_return("Success! Your action has been removed from the actions list.");
            remscenmenu();
        }
    }
}
if (rscm == "ak3")
{
    m.fade_music();
    attacks.open("data/scenarios/" + senpack + "/attacks.list", "r");
    attacksplit = attacks.read();
    attacks.close();
    string[] rawAttacks = string_split(attacksplit, "\r\n", true);
    string[] filteredAttacks;
    uint[] originalIndexes;
    filter_empty_lines(rawAttacks, filteredAttacks, originalIndexes);
    if (filteredAttacks.length() == 0)
    {
        alert("Error", "There are no attacks available to remove.");
        wait(500);
        remscenmenu();
    }
    setupmenu(false);
    for (uint i = 0; i < filteredAttacks.length(); i++)
    {
        m.add_item_tts(filteredAttacks[i], filteredAttacks[i], "", true);
    }
    int mres = m.run("Select an attack to remove", true);
    if (mres == 0)
    {
        remscenmenu();
    }
    if (mres > 0 and mres <= filteredAttacks.length())
    {
        int realIndex = originalIndexes[mres - 1];
        if (realIndex >= 0 and realIndex < rawAttacks.length())
        {
            rawAttacks.remove_at(realIndex);
            string final = "";
            for (uint i = 0; i < rawAttacks.length(); i++)
            {
                final += rawAttacks[i] + "\r\n";
            }
            attacks.open("data/scenarios/" + senpack + "/attacks.list", "w");
            attacks.write(final);
            attacks.close();
            dlg_return("Success! Your attack has been removed from the attacks list.");
            remscenmenu();
        }
    }
}
if (rscm == "bpart3")
{
    m.fade_music();
    bodyparts.open("data/scenarios/" + senpack + "/bodyparts.list", "r");
    bodypartsplit = bodyparts.read();
    bodyparts.close();
    string[] rawBodyparts = string_split(bodypartsplit, "\r\n", true);
    string[] filteredBodyparts;
    uint[] originalIndexes;
    filter_empty_lines(rawBodyparts, filteredBodyparts, originalIndexes);
    if (filteredBodyparts.length() == 0)
    {
        alert("Error", "There are no body parts available to remove.");
        wait(500);
        remscenmenu();
    }
    setupmenu(false);
    for (uint i = 0; i < filteredBodyparts.length(); i++)
    {
        m.add_item_tts(filteredBodyparts[i], filteredBodyparts[i], "", true);
    }
    int mres = m.run("Select a bodypart to remove", true);
    if (mres == 0)
    {
        remscenmenu();
    }
    if (mres > 0 and mres <= filteredBodyparts.length())
    {
        int realIndex = originalIndexes[mres - 1];
        if (realIndex >= 0 and realIndex < rawBodyparts.length())
        {
            rawBodyparts.remove_at(realIndex);
            string final = "";
            for (uint i = 0; i < rawBodyparts.length(); i++)
            {
                final += rawBodyparts[i] + "\r\n";
            }
            bodyparts.open("data/scenarios/" + senpack + "/bodyparts.list", "w");
            bodyparts.write(final);
            bodyparts.close();
            dlg_return("Success! Your body part has been removed from the bodyparts list.");
            remscenmenu();
        }
    }
}
if (rscm == "cname3")
{
    m.fade_music();
    charnames.open("data/scenarios/" + senpack + "/charnames.list", "r");
    charnamesplit = charnames.read();
    charnames.close();
    string[] rawCharnames = string_split(charnamesplit, "\r\n", true);
    string[] filteredCharnames;
    uint[] originalIndexes;
    filter_empty_lines(rawCharnames, filteredCharnames, originalIndexes);
    if (filteredCharnames.length() == 0)
    {
        alert("Error", "There are no character names available to remove.");
        wait(500);
        remscenmenu();
    }
    setupmenu(false);
    for (uint i = 0; i < filteredCharnames.length(); i++)
    {
        m.add_item_tts(filteredCharnames[i], filteredCharnames[i], "", true);
    }
    int mres = m.run("Select a character name to remove", true);
    if (mres == 0)
    {
        remscenmenu();
    }
    if (mres > 0 and mres <= filteredCharnames.length())
    {
        int realIndex = originalIndexes[mres - 1];
        if (realIndex >= 0 and realIndex < rawCharnames.length())
        {
            rawCharnames.remove_at(realIndex);
            string final = "";
            for (uint i = 0; i < rawCharnames.length(); i++)
            {
                final += rawCharnames[i] + "\r\n";
            }
            charnames.open("data/scenarios/" + senpack + "/charnames.list", "w");
            charnames.write(final);
            charnames.close();
            dlg_return("Success! Your character name has been removed from the character names list.");
            remscenmenu();
        }
    }
}
if (rscm == "ctype3")
{
    m.fade_music();
    chartypes.open("data/scenarios/" + senpack + "/chartypes.list", "r");
    chartypesplit = chartypes.read();
    chartypes.close();
    string[] rawChartypes = string_split(chartypesplit, "\r\n", true);
    string[] filteredChartypes;
    uint[] originalIndexes;
    filter_empty_lines(rawChartypes, filteredChartypes, originalIndexes);
    if (filteredChartypes.length() == 0)
    {
        alert("Error", "There are no character types available to remove.");
        wait(500);
        remscenmenu();
    }
    setupmenu(false);
    for (uint i = 0; i < filteredChartypes.length(); i++)
    {
        m.add_item_tts(filteredChartypes[i], filteredChartypes[i], "", true);
    }
    int mres = m.run("Select a character type to remove", true);
    if (mres == 0)
    {
        remscenmenu();
    }
    if (mres > 0 and mres <= filteredChartypes.length())
    {
        int realIndex = originalIndexes[mres - 1];
        if (realIndex >= 0 and realIndex < rawChartypes.length())
        {
            rawChartypes.remove_at(realIndex);
            string final = "";
            for (uint i = 0; i < rawChartypes.length(); i++)
            {
                final += rawChartypes[i] + "\r\n";
            }
            chartypes.open("data/scenarios/" + senpack + "/chartypes.list", "w");
            chartypes.write(final);
            chartypes.close();
            dlg_return("Success! Your character type has been removed from the character types list.");
            remscenmenu();
        }
    }
}
if (rscm == "dmessage3")
{
    m.fade_music();
    deaths.open("data/scenarios/" + senpack + "/deaths.list", "r");
    deathsplit = deaths.read();
    deaths.close();
    string[] rawDeaths = string_split(deathsplit, "\r\n", true);
    string[] filteredDeaths;
    uint[] originalIndexes;
    filter_empty_lines(rawDeaths, filteredDeaths, originalIndexes);
    if (filteredDeaths.length() == 0)
    {
        alert("Error", "There are no death messages available to remove.");
        wait(500);
        remscenmenu();
    }
    setupmenu(false);
    for (uint i = 0; i < filteredDeaths.length(); i++)
    {
        m.add_item_tts(filteredDeaths[i], filteredDeaths[i], "", true);
    }
    int mres = m.run("Select a death message to remove", true);
    if (mres == 0)
    {
        remscenmenu();
    }
    if (mres > 0 and mres <= filteredDeaths.length())
    {
        int realIndex = originalIndexes[mres - 1];
        if (realIndex >= 0 and realIndex < rawDeaths.length())
        {
            rawDeaths.remove_at(realIndex);
            string final = "";
            for (uint i = 0; i < rawDeaths.length(); i++)
            {
                final += rawDeaths[i] + "\r\n";
            }
            deaths.open("data/scenarios/" + senpack + "/deaths.list", "w");
            deaths.write(final);
            deaths.close();
            dlg_return("Success! Your death message has been removed from the death messages list.");
            remscenmenu();
        }
    }
}
if (rscm == "mod3")
{
    m.fade_music();
    moods.open("data/scenarios/" + senpack + "/moods.list", "r");
    moodsplit = moods.read();
    moods.close();
    string[] rawMoods = string_split(moodsplit, "\r\n", true);
    string[] filteredMoods;
    uint[] originalIndexes;
    filter_empty_lines(rawMoods, filteredMoods, originalIndexes);
    if (filteredMoods.length() == 0)
    {
        alert("Error", "There are no moods available to remove.");
        wait(500);
        remscenmenu();
    }
    setupmenu(false);
    for (uint i = 0; i < filteredMoods.length(); i++)
    {
        m.add_item_tts(filteredMoods[i], filteredMoods[i], "", true);
    }
    int mres = m.run("Select a mood to remove", true);
    if (mres == 0)
    {
        remscenmenu();
    }
    if (mres > 0 and mres <= filteredMoods.length())
    {
        int realIndex = originalIndexes[mres - 1];
        if (realIndex >= 0 and realIndex < rawMoods.length())
        {
            rawMoods.remove_at(realIndex);
            string final = "";
            for (uint i = 0; i < rawMoods.length(); i++)
            {
                final += rawMoods[i] + "\r\n";
            }
            moods.open("data/scenarios/" + senpack + "/moods.list", "w");
            moods.write(final);
            moods.close();
            dlg_return("Success! Your mood has been removed from the moods list.");
            remscenmenu();
        }
    }
}
if (rscm == "pmessage3")
{
    m.fade_music();
    pains.open("data/scenarios/" + senpack + "/pains.list", "r");
    painsplit = pains.read();
    pains.close();
    string[] rawPains = string_split(painsplit, "\r\n", true);
    string[] filteredPains;
    uint[] originalIndexes;
    filter_empty_lines(rawPains, filteredPains, originalIndexes);
    if (filteredPains.length() == 0)
    {
        alert("Error", "There are no pain messages available to remove.");
        wait(500);
        remscenmenu();
    }
    setupmenu(false);
    for (uint i = 0; i < filteredPains.length(); i++)
    {
        m.add_item_tts(filteredPains[i], filteredPains[i], "", true);
    }
    int mres = m.run("Select a pain message to remove", true);
    if (mres == 0)
    {
        remscenmenu();
    }
    if (mres > 0 and mres <= filteredPains.length())
    {
        int realIndex = originalIndexes[mres - 1];
        if (realIndex >= 0 and realIndex < rawPains.length())
        {
            rawPains.remove_at(realIndex);
            string final = "";
            for (uint i = 0; i < rawPains.length(); i++)
            {
                final += rawPains[i] + "\r\n";
            }
            pains.open("data/scenarios/" + senpack + "/pains.list", "w");
            pains.write(final);
            pains.close();
            dlg_return("Success! Your pain message has been removed from the pain messages list.");
            remscenmenu();
        }
    }
}
if (rscm == "res3")
{
    m.fade_music();
    reasons.open("data/scenarios/" + senpack + "/reasons.list", "r");
    reasonsplit = reasons.read();
    reasons.close();
    string[] rawReasons = string_split(reasonsplit, "\r\n", true);
    string[] filteredReasons;
    uint[] originalIndexes;
    filter_empty_lines(rawReasons, filteredReasons, originalIndexes);
    if (filteredReasons.length() == 0)
    {
        alert("Error", "There are no reasons available to remove.");
        wait(500);
        remscenmenu();
    }
    setupmenu(false);
    for (uint i = 0; i < filteredReasons.length(); i++)
    {
        m.add_item_tts(filteredReasons[i], filteredReasons[i], "", true);
    }
    int mres = m.run("Select a reason to remove", true);
    if (mres == 0)
    {
        remscenmenu();
    }
    if (mres > 0 and mres <= filteredReasons.length())
    {
        int realIndex = originalIndexes[mres - 1];
        if (realIndex >= 0 and realIndex < rawReasons.length())
        {
            rawReasons.remove_at(realIndex);
            string final = "";
            for (uint i = 0; i < rawReasons.length(); i++)
            {
                final += rawReasons[i] + "\r\n";
            }
            reasons.open("data/scenarios/" + senpack + "/reasons.list", "w");
            reasons.write(final);
            reasons.close();
            dlg_return("Success! Your reason has been removed from the reasons list.");
            remscenmenu();
        }
    }
}
if(rscm == "temps3")
{
    m.fade_music();
    templates.open("data/scenarios/" + senpack + "/templates.list", "r");
    string contents = templates.read();
    templates.close();
    string[] lines = string_split(contents, "\r\n", true);
    string[] categories;
    uint[] indices;
    for (uint i = 0; i < lines.length(); i++)
    {
        if (lines[i].starts_with("[") && lines[i].ends_with("]"))
        {
            categories.insert_last(lines[i].substr(1, lines[i].length() - 2));
            indices.insert_last(i);
        }
    }
    if(categories.length() == 0)
    {
        alert("Error", "There are no template categories available to remove.");
        wait(500);
        remscenmenu();
    }
    setupmenu(false);
    for (uint i = 0; i < categories.length(); i++)
    {
        m.add_item_tts(categories[i], categories[i], "", true);
    }
    int mres = m.run("Select a template category to remove", true);
    if (mres == 0)
    {
        remscenmenu();
    }
    if (mres > 0 && mres <= categories.length())
    {
        int start = indices[mres - 1];
        int end = lines.length();
        for (uint j = start + 1; j < lines.length(); j++)
        {
            if (lines[j].starts_with("[") && lines[j].ends_with("]"))
            {
                end = j;
                break;
            }
        }
        for (int k = end - 1; k >= start; k--)
        {
            lines.remove_at(k);
        }
        templates.open("data/scenarios/" + senpack + "/templates.list", "w");
        for (uint i = 0; i < lines.length(); i++)
        {
            templates.write(lines[i] + "\r\n");
        }
        templates.close();
dlg_return("Success! Your template category has been removed from the templates list.");
        remscenmenu();
    }
}
if(rscm=="back")
{
scencredmenu();
}
}
void vewscenmenu()
{
setupmenu();
m.add_item_tts("actions", "act4");
m.add_item_tts("attacks", "ak4");
m.add_item_tts("body parts", "bpart4");
m.add_item_tts("character names", "cname4");
m.add_item_tts("character types", "ctype4");
m.add_item_tts("death messages", "dmessage4");
m.add_item_tts("moods", "mod4");
m.add_item_tts("pain messages", "pmessage4");
m.add_item_tts("reasons", "res4");
m.add_item_tts("template categories", "temps4");
m.add_item_tts("back", "back");
int mres=m.run("View scenarios menu. What would you like to view?",true);
string vscm=m.get_item_name(mres);
if(mres==0)
{
scencredmenu();
}
if(vscm=="act4")
{
    m.fade_music();
    actions.open("data/scenarios/" + senpack + "/actions.list", "r");
    actionsplit = actions.read();
    actions.close();
    action = string_split(actionsplit, "\r\n", true);
    string[] filtered_actions;
    uint[] original_indices;
    filter_empty_lines(action, filtered_actions, original_indices);
    if(filtered_actions.length() == 0)
    {
        alert("Error", "There are no actions available to view.");
        wait(500);
        vewscenmenu();
    }
    setupmenu(false);
    for(uint i = 0; i < filtered_actions.length(); i++)
    {
        m.add_item_tts(filtered_actions[i], "", "", false);
    }
    int mres = m.run("Actions viewer", true);
    if(mres == 0)
    {
        vewscenmenu();
    }
    if(mres > 0 && mres <= filtered_actions.length())
    {
        return;
    }
}
if(vscm=="ak4")
{
    m.fade_music();
    attacks.open("data/scenarios/" + senpack + "/attacks.list", "r");
    attacksplit = attacks.read();
    attacks.close();
    attack = string_split(attacksplit, "\r\n", true);
    string[] filtered_attacks;
    uint[] original_indices;
    filter_empty_lines(attack, filtered_attacks, original_indices);
    if(filtered_attacks.length() == 0)
    {
        alert("Error", "There are no attacks available to view.");
        wait(500);
        vewscenmenu();
    }
setupmenu(false);
    for(uint i = 0; i < filtered_attacks.length(); i++)
    {
        m.add_item_tts(filtered_attacks[i], "", "", false);
    }
    int mres = m.run("attacks viewer", true);
    if(mres == 0)
    {
        vewscenmenu();
    }
    if(mres > 0 && mres <= filtered_attacks.length())
    {
        return;
    }
}
if(vscm=="bpart4")
{
    m.fade_music();
    bodyparts.open("data/scenarios/" + senpack + "/bodyparts.list", "r");
    bodypartsplit = bodyparts.read();
    bodyparts.close();
    bodypart = string_split(bodypartsplit, "\r\n", true);
    string[] filtered_bodyparts;
    uint[] original_indices;
    filter_empty_lines(bodypart, filtered_bodyparts, original_indices);
    if(filtered_bodyparts.length() == 0)
    {
        alert("Error", "There are no body parts available to view.");
        wait(500);
        vewscenmenu();
    }
setupmenu(false);
    for(uint i = 0; i < filtered_bodyparts.length(); i++)
    {
        m.add_item_tts(filtered_bodyparts[i], "", "", false);
    }
    int mres = m.run("body parts viewer", true);
    if(mres == 0)
    {
        vewscenmenu();
    }
    if(mres > 0 && mres <= filtered_bodyparts.length())
    {
        return;
    }
}
if(vscm=="cname4")
{
    m.fade_music();
    charnames.open("data/scenarios/" + senpack + "/charnames.list", "r");
    charnamesplit = charnames.read();
    charnames.close();
    charname = string_split(charnamesplit, "\r\n", true);
    string[] filtered_charnames;
    uint[] original_indices;
    filter_empty_lines(charname, filtered_charnames, original_indices);
    if(filtered_charnames.length() == 0)
    {
        alert("Error", "There are no character names available to view.");
        wait(500);
        vewscenmenu();
    }
    setupmenu(false);
    for(uint i = 0; i < filtered_charnames.length(); i++)
    {
        m.add_item_tts(filtered_charnames[i], "", "", false);
    }
    int mres = m.run("character names viewer", true);
    if(mres == 0)
    {
        vewscenmenu();
    }
    if(mres > 0 && mres <= filtered_charnames.length())
    {
        return;
    }
}
if(vscm=="ctype4")
{
    m.fade_music();
    chartypes.open("data/scenarios/" + senpack + "/chartypes.list", "r");
    chartypesplit = chartypes.read();
    chartypes.close();
    chartype = string_split(chartypesplit, "\r\n", true);
    string[] filtered_chartypes;
    uint[] original_indices;
    filter_empty_lines(chartype, filtered_chartypes, original_indices);
    if(filtered_chartypes.length() == 0)
    {
        alert("Error", "There are no character types available to view.");
        wait(500);
        vewscenmenu();
    }
    setupmenu(false);
    for(uint i = 0; i < filtered_chartypes.length(); i++)
    {
        m.add_item_tts(filtered_chartypes[i], "", "", false);
    }
    int mres = m.run("character types viewer", true);
    if(mres == 0)
    {
        vewscenmenu();
    }
    if(mres > 0 && mres <= filtered_chartypes.length())
    {
        return;
    }
}
if(vscm=="dmessage4")
{
    m.fade_music();
    deaths.open("data/scenarios/" + senpack + "/deaths.list", "r");
    deathsplit = deaths.read();
    deaths.close();
    death = string_split(deathsplit, "\r\n", true);
    string[] filtered_deaths;
    uint[] original_indices;
    filter_empty_lines(death, filtered_deaths, original_indices);
    if(filtered_deaths.length() == 0)
    {
        alert("Error", "There are no death messages available to view.");
        wait(500);
        vewscenmenu();
    }
    setupmenu(false);
    for(uint i = 0; i < filtered_deaths.length(); i++)
    {
        m.add_item_tts(filtered_deaths[i], "", "", false);
    }
    int mres = m.run("death messages viewer", true);
    if(mres == 0)
    {
        vewscenmenu();
    }
    if(mres > 0 && mres <= filtered_deaths.length())
    {
        return;
    }
}
if(vscm=="mod4")
{
    m.fade_music();
    moods.open("data/scenarios/" + senpack + "/moods.list", "r");
    moodsplit = moods.read();
    moods.close();
    mood = string_split(moodsplit, "\r\n", true);
    string[] filtered_moods;
    uint[] original_indices;
    filter_empty_lines(mood, filtered_moods, original_indices);
    if(filtered_moods.length() == 0)
    {
        alert("Error", "There are no moods available to view.");
        wait(500);
        vewscenmenu();
    }
    setupmenu(false);
    for(uint i = 0; i < filtered_moods.length(); i++)
    {
        m.add_item_tts(filtered_moods[i], "", "", false);
    }
    int mres = m.run("moods viewer", true);
    if(mres == 0)
    {
        vewscenmenu();
    }
    if(mres > 0 && mres <= filtered_moods.length())
    {
        return;
    }
}
if(vscm=="pmessage4")
{
    m.fade_music();
    pains.open("data/scenarios/" + senpack + "/pains.list", "r");
    painsplit = pains.read();
    pains.close();
    pain = string_split(painsplit, "\r\n", true);
    string[] filtered_pains;
    uint[] original_indices;
    filter_empty_lines(pain, filtered_pains, original_indices);
    if(filtered_pains.length() == 0)
    {
        alert("Error", "There are no pain messages available to view.");
        wait(500);
        vewscenmenu();
    }
    setupmenu(false);
    for(uint i = 0; i < filtered_pains.length(); i++)
    {
        m.add_item_tts(filtered_pains[i], "", "", false);
    }
    int mres = m.run("pain messages viewer", true);
    if(mres == 0)
    {
        vewscenmenu();
    }
    if(mres > 0 && mres <= filtered_pains.length())
    {
        return;
    }
}
if(vscm=="res4")
{
    m.fade_music();
    reasons.open("data/scenarios/" + senpack + "/reasons.list", "r");
    reasonsplit = reasons.read();
    reasons.close();
    reason = string_split(reasonsplit, "\r\n", true);
    string[] filtered_reasons;
    uint[] original_indices;
    filter_empty_lines(reason, filtered_reasons, original_indices);
    if(filtered_reasons.length() == 0)
    {
        alert("Error", "There are no reasons available to view.");
        wait(500);
        vewscenmenu();
    }
    setupmenu(false);
    for(uint i = 0; i < filtered_reasons.length(); i++)
    {
        m.add_item_tts(filtered_reasons[i], "", "", false);
    }
    int mres = m.run("reasons viewer", true);
    if(mres == 0)
    {
        vewscenmenu();
    }
    if(mres > 0 && mres <= filtered_reasons.length())
    {
        return;
    }
}
if(vscm == "temps4")
{
    m.fade_music();
    templates.open("data/scenarios/" + senpack + "/templates.list", "r");
    string contents = templates.read();
    templates.close();
    string[] lines = string_split(contents, "\r\n", true);
    string[] entries;
    for (uint i = 0; i < lines.length(); i++)
    {
        if (lines[i].starts_with("[") && lines[i].ends_with("]") && i + 1 < lines.length())
        {
            string category = lines[i].substr(1, lines[i].length() - 2);
            string template = lines[i + 1];
            entries.insert_last(category + ": " + template);
        }
    }
    if (entries.length() == 0)
    {
        alert("Error", "There are no template categories available to view.");
        wait(500);
        vewscenmenu();
    }
    setupmenu(false);
    for (uint i = 0; i < entries.length(); i++)
    {
        m.add_item_tts(entries[i], "", "", false);
    }
    int mres = m.run("Template categories viewer", true);
    if (mres == 0)
    {
        vewscenmenu();
    }
    if (mres > 0 && mres <= entries.length())
    {
        return;
    }
}
if(vscm=="back")
{
scencredmenu();
}
}
void statsmenu()
{
getscen();
setupmenu();
    m.add_item_tts("Actions: " + count_non_empty(action) + " entries.");
    m.add_item_tts("Attacks: " + count_non_empty(attack) + " entries.");
    m.add_item_tts("Body parts: " + count_non_empty(bodypart) + " entries.");
    m.add_item_tts("Character names: " + count_non_empty(charname) + " entries.");
    m.add_item_tts("Character types: " + count_non_empty(chartype) + " entries.");
    deaths.open("data/scenarios/" + senpack + "/deaths.list", "r");
    deathsplit = deaths.read();
    death = string_split(deathsplit, "\r\n", true);
    m.add_item_tts("Death messages: " + count_non_empty(death) + " entries.");
    m.add_item_tts("Moods: " + count_non_empty(mood) + " entries.");
    m.add_item_tts("Pain messages: " + count_non_empty(pain) + " entries.");
    m.add_item_tts("Reasons: " + count_non_empty(reason) + " entries.");
    templates.open("data/scenarios/" + senpack + "/templates.list", "r");
    string tempData = templates.read();
    templates.close();
    string[] tempLines = string_split(tempData, "\r\n", true);
    int templateCount = 0;
    for (uint i = 0; i < tempLines.length(); i++)
    {
        string trimmed = string_trim_sides(tempLines[i]);
        if (trimmed.starts_with("[") && trimmed.ends_with("]"))
            templateCount++;
    }
    m.add_item_tts("Template categories: " + templateCount + " entries.");
m.add_item_tts("back", "back");
string[] senarpacks=find_directories("data/scenarios/*");
int mres;
if(senarpacks.length()==1) mres=m.run("Scenario statistics menu.",true);
else if(senarpacks.length()>1) mres=m.run(senpack+" loaded: Scenario statistics menu.",true);
string stm=m.get_item_name(mres);
if(mres==0 or mres>=m.get_item_name(mres))
{
mainmenu();
}
if(stm=="back")
{
mainmenu();
}
}
